package step_c_patterns_test

import (
	"testing"

	"github.com/aether-engine/aether-engine/internal/combat/combatfacade"
	"github.com/aether-engine/aether-engine/internal/combat/combatinitializer"
	"github.com/aether-engine/aether-engine/internal/combat/domain"
	"github.com/aether-engine/aether-engine/internal/combat/domain/states"
	shared "github.com/aether-engine/aether-engine/internal/shared/domain"
)

// Test du flux complet de combat : Idle → BattleEnded
func TestIntegration_FullCombatFlow(t *testing.T) {
	// Arrange - Créer un combat avec 2 unités
	combat := createTestCombat()

	ally := createTestUnit("A1", 100)
	ally.SetPosition(shared.NewPosition(0, 0))
	ally.SetTeam(domain.TeamID("team_ally"))
	ally.SetHP(200)
	ally.SetMP(100)

	enemy := createTestUnit("E1", 50)
	enemy.SetPosition(shared.NewPosition(1, 0))
	enemy.SetTeam(domain.TeamID("team_enemy"))
	enemy.SetHP(50)

	combat.AjouterUnite(ally)
	combat.AjouterUnite(enemy)

	// Initialiser Step C
	combatinitializer.InitializeStepC(combat)

	// Act - Dérouler le combat
	// 1. Idle → Initializing
	err := combatfacade.TransitionToState(combat, states.EventInitialize)
	if err != nil {
		t.Fatalf("Échec de la transition Idle → Initializing: %v", err)
	}

	// 2. Initializing → Ready
	err = combatfacade.TransitionToState(combat, states.EventInitializationComplete)
	if err != nil {
		t.Fatalf("Échec de la transition Initializing → Ready: %v", err)
	}

	currentState := combatfacade.GetCurrentStateString(combat)
	if currentState != "Ready" {
		t.Errorf("État attendu: Ready, obtenu: %s", currentState)
	}

	// 3. Simuler un tour complet
	// Ready → WaitingATB (tick ATB jusqu'à ce qu'une unité soit prête)
	for i := 0; i < 100; i++ {
		combatfacade.TickATB(combat, 10)

		nextUnit := combatfacade.GetNextReadyUnit(combat)
		if nextUnit != nil {
			// 4. WaitingATB → TurnBegin
			err = combatfacade.TransitionToState(combat, states.EventNextUnitReady)
			if err != nil {
				t.Fatalf("Échec de la transition WaitingATB → TurnBegin: %v", err)
			}
			break
		}
	}

	// 5. TurnBegin → ActionSelection
	err = combatfacade.TransitionToState(combat, states.EventTurnStart)
	if err != nil {
		t.Fatalf("Échec de la transition TurnBegin → ActionSelection: %v", err)
	}

	// 6. ActionSelection → Validating (exécuter une attaque)
	result, err := combatfacade.ExecutePlayerAction(combat, ally.ID(),
		combatfacade.CommandTypeAttack, map[string]interface{}{
			"targetID": enemy.ID(),
		})

	if err != nil {
		t.Fatalf("Échec de l'exécution de l'action: %v", err)
	}

	// Assert - Vérifier que l'ennemi est mort et le combat terminé
	if enemy.HP() > 0 {
		t.Logf("L'ennemi a encore %d HP, plusieurs tours peuvent être nécessaires", enemy.HP())
	}

	if result != nil && result.Success && enemy.HP() <= 0 {
		// 7. CheckVictory détectera la victoire
		err = combatfacade.TransitionToState(combat, states.EventCheckVictory)
		if err == nil {
			finalState := combatfacade.GetCurrentStateString(combat)
			if finalState == "BattleEnded" || finalState == "Finalizing" {
				t.Logf("✅ Combat terminé avec succès, état final: %s", finalState)
			}
		}
	}
}

// Test du scénario de victoire (tous les ennemis vaincus)
func TestIntegration_VictoryScenario(t *testing.T) {
	// Arrange
	combat := createTestCombat()

	ally := createTestUnit("A1", 100)
	ally.SetTeam(domain.TeamID("team_ally"))
	ally.SetHP(200)

	enemy := createTestUnit("E1", 50)
	enemy.SetTeam(domain.TeamID("team_enemy"))
	enemy.SetHP(1) // Presque mort

	combat.AjouterUnite(ally)
	combat.AjouterUnite(enemy)

	combatinitializer.InitializeStepC(combat)

	// Act - Tuer l'ennemi
	enemy.SetHP(0)

	// Transition vers CheckVictory
	err := combatfacade.TransitionToState(combat, states.EventCheckVictory)
	if err != nil {
		t.Fatalf("Échec de la transition vers CheckVictory: %v", err)
	}

	// Assert - Le combat devrait détecter la victoire
	currentState := combatfacade.GetCurrentStateString(combat)
	if currentState != "BattleEnded" && currentState != "Finalizing" {
		t.Errorf("Le combat devrait être terminé (victoire), état: %s", currentState)
	}

	// Vérifier le résultat de victoire
	combatResult := combat.Resultat()
	if combatResult == nil {
		t.Errorf("Le résultat du combat devrait être défini")
	}
}

// Test du scénario de défaite (tous les alliés vaincus)
func TestIntegration_DefeatScenario(t *testing.T) {
	// Arrange
	combat := createTestCombat()

	ally := createTestUnit("A1", 100)
	ally.SetTeam(domain.TeamID("team_ally"))
	ally.SetHP(1) // Presque mort

	enemy := createTestUnit("E1", 50)
	enemy.SetTeam(domain.TeamID("team_enemy"))
	enemy.SetHP(200)

	combat.AjouterUnite(ally)
	combat.AjouterUnite(enemy)

	combatinitializer.InitializeStepC(combat)

	// Act - Tuer l'allié
	ally.SetHP(0)

	// Transition vers CheckVictory
	err := combatfacade.TransitionToState(combat, states.EventCheckVictory)
	if err != nil {
		t.Fatalf("Échec de la transition vers CheckVictory: %v", err)
	}

	// Assert - Le combat devrait détecter la défaite
	currentState := combatfacade.GetCurrentStateString(combat)
	if currentState != "BattleEnded" && currentState != "Finalizing" {
		t.Errorf("Le combat devrait être terminé (défaite), état: %s", currentState)
	}

	// Vérifier le résultat de défaite
	combatResult := combat.Resultat()
	if combatResult == nil {
		t.Errorf("Le résultat du combat devrait être défini")
	}
}

// Test du scénario de fuite réussie
func TestIntegration_FleeSuccess(t *testing.T) {
	// Arrange
	combat := createTestCombat()

	ally := createTestUnit("A1", 200) // Speed très élevé = fuite facile
	ally.SetTeam(domain.TeamID("team_ally"))
	ally.SetHP(100)
	ally.SetPosition(shared.NewPosition(0, 0))

	enemy := createTestUnit("E1", 10) // Speed faible
	enemy.SetTeam(domain.TeamID("team_enemy"))
	enemy.SetHP(200)
	enemy.SetPosition(shared.NewPosition(5, 5))

	combat.AjouterUnite(ally)
	combat.AjouterUnite(enemy)

	combatinitializer.InitializeStepC(combat)

	// Act - Tenter de fuir (plusieurs tentatives pour gérer l'aléatoire)
	fleeAttempts := 0
	maxAttempts := 50
	fleeSucceeded := false

	for fleeAttempts < maxAttempts {
		result, err := combatfacade.ExecutePlayerAction(combat, ally.ID(),
			combatfacade.CommandTypeFlee, nil)

		if err == nil && result != nil && result.Success {
			fleeSucceeded = true
			break
		}
		fleeAttempts++
	}

	// Assert
	if !fleeSucceeded {
		t.Logf("Fuite non réussie après %d tentatives (attendu avec speed élevé)", maxAttempts)
	} else {
		t.Logf("✅ Fuite réussie après %d tentatives", fleeAttempts+1)

		// Vérifier que le combat est terminé
		currentState := combatfacade.GetCurrentStateString(combat)
		if currentState != "BattleEnded" && currentState != "Finalizing" {
			t.Logf("État après fuite: %s", currentState)
		}
	}
}

// Test du scénario d'action rejetée + nouvelle tentative
func TestIntegration_ActionRejectedRetry(t *testing.T) {
	// Arrange
	combat := createTestCombat()

	ally := createTestUnit("A1", 100)
	ally.SetTeam(domain.TeamID("team_ally"))
	ally.SetHP(100)
	ally.SetMP(10) // Pas assez de MP pour une compétence coûteuse
	ally.SetPosition(shared.NewPosition(0, 0))

	enemy := createTestUnit("E1", 50)
	enemy.SetTeam(domain.TeamID("team_enemy"))
	enemy.SetHP(100)
	enemy.SetPosition(shared.NewPosition(9, 9)) // Très loin

	combat.AjouterUnite(ally)
	combat.AjouterUnite(enemy)

	combatinitializer.InitializeStepC(combat)

	// Act - Essayer une action invalide (attaque hors portée)
	result1, err1 := combatfacade.ExecutePlayerAction(combat, ally.ID(),
		combatfacade.CommandTypeAttack, map[string]interface{}{
			"targetID": enemy.ID(),
		})

	// Assert - La première action devrait échouer
	if err1 == nil && result1 != nil && result1.Success {
		t.Errorf("L'attaque hors portée devrait échouer")
	}

	// Act - Réessayer avec une action valide (Wait)
	result2, err2 := combatfacade.ExecutePlayerAction(combat, ally.ID(),
		combatfacade.CommandTypeWait, nil)

	// Assert - La deuxième action devrait réussir
	if err2 != nil || result2 == nil || !result2.Success {
		t.Errorf("L'action Wait devrait réussir après rejet: err=%v", err2)
	}

	currentState := combatfacade.GetCurrentStateString(combat)
	t.Logf("État après retry: %s", currentState)
}

// Test de l'intégration State Machine + Command Pattern
func TestIntegration_StateMachineWithCommands(t *testing.T) {
	// Arrange
	combat := createTestCombat()

	unit := createTestUnit("U1", 100)
	unit.SetPosition(shared.NewPosition(5, 5))
	unit.SetHP(100)
	unit.SetMP(100)

	combat.AjouterUnite(unit)
	combatinitializer.InitializeStepC(combat)

	// Act - Exécuter plusieurs commandes et observer les transitions
	commands := []combatfacade.CommandType{
		combatfacade.CommandTypeWait,
		combatfacade.CommandTypeWait,
		combatfacade.CommandTypeWait,
	}

	for i, cmdType := range commands {
		result, err := combatfacade.ExecutePlayerAction(combat, unit.ID(), cmdType, nil)

		if err != nil {
			t.Errorf("Commande %d (%s) a échoué: %v", i+1, cmdType, err)
			continue
		}

		if result == nil || !result.Success {
			t.Errorf("Commande %d (%s) devrait réussir", i+1, cmdType)
		}

		// Vérifier que la state machine a transitionné
		currentState := combatfacade.GetCurrentStateString(combat)
		t.Logf("Après commande %d: état = %s", i+1, currentState)
	}

	// Assert - Vérifier l'historique des commandes
	if combatfacade.CanUndo(combat) {
		t.Logf("✅ Historique de commandes disponible pour Undo")
	}
}

// Test de l'intégration Observer Pattern + State Machine
func TestIntegration_ObserversWithStateMachine(t *testing.T) {
	// Arrange
	combat := createTestCombat()

	unit := createTestUnit("U1", 100)
	combat.AjouterUnite(unit)

	combatinitializer.InitializeStepC(combat)

	// Récupérer le subject pour vérifier les observers
	subject := combatfacade.GetSubject(combat)
	if subject == nil {
		t.Fatalf("CombatSubject ne devrait pas être nil")
	}

	initialObserverCount := subject.ObserverCount()
	if initialObserverCount == 0 {
		t.Errorf("Des observers devraient être attachés par défaut")
	}

	// Act - Provoquer des transitions d'état
	combatfacade.TransitionToState(combat, states.EventInitialize)
	combatfacade.TransitionToState(combat, states.EventInitializationComplete)

	// Assert - Les observers devraient avoir été notifiés
	// (Vérification indirecte via logs ou compteurs si implémentés)
	t.Logf("✅ Observers notifiés pour les transitions d'état")
}

// Test de l'intégration Validation Chain + Command Pattern
func TestIntegration_ValidationChainWithCommands(t *testing.T) {
	// Arrange
	combat := createTestCombat()

	attacker := createTestUnit("A1", 100)
	attacker.SetPosition(shared.NewPosition(0, 0))
	attacker.SetTeam(domain.TeamID("team_ally"))
	attacker.SetHP(100)
	attacker.SetMP(100)

	target := createTestUnit("E1", 50)
	target.SetPosition(shared.NewPosition(1, 0))
	target.SetTeam(domain.TeamID("team_enemy"))
	target.SetHP(100)

	combat.AjouterUnite(attacker)
	combat.AjouterUnite(target)

	combatinitializer.InitializeStepC(combat)

	// Act - Exécuter une commande qui passera tous les validateurs
	result, err := combatfacade.ExecutePlayerAction(combat, attacker.ID(),
		combatfacade.CommandTypeAttack, map[string]interface{}{
			"targetID": target.ID(),
		})

	// Assert
	if err != nil {
		t.Errorf("La commande devrait passer tous les validateurs: %v", err)
	}

	if result == nil || !result.Success {
		t.Errorf("La commande devrait s'exécuter avec succès")
	}

	// Vérifier que la cible a pris des dégâts
	if target.HP() >= 100 {
		t.Errorf("La cible devrait avoir perdu des HP")
	}

	t.Logf("✅ Validation Chain + Command Pattern intégrés avec succès")
}

// Test complet de tous les patterns ensemble
func TestIntegration_AllPatternsTogether(t *testing.T) {
	// Arrange - Créer un combat réaliste
	combat := createTestCombat()

	// Équipe alliée
	warrior := createTestUnit("W1", 80)
	warrior.SetPosition(shared.NewPosition(0, 0))
	warrior.SetTeam(domain.TeamID("team_ally"))
	warrior.SetHP(200)
	warrior.SetMP(50)

	mage := createTestUnit("M1", 60)
	mage.SetPosition(shared.NewPosition(0, 1))
	mage.SetTeam(domain.TeamID("team_ally"))
	mage.SetHP(100)
	mage.SetMP(200)

	// Équipe ennemie
	goblin := createTestUnit("G1", 100)
	goblin.SetPosition(shared.NewPosition(9, 9))
	goblin.SetTeam(domain.TeamID("team_enemy"))
	goblin.SetHP(50)

	combat.AjouterUnite(warrior)
	combat.AjouterUnite(mage)
	combat.AjouterUnite(goblin)

	combatinitializer.InitializeStepC(combat)

	// Act - Simuler plusieurs tours
	t.Log("=== Début du combat ===")

	// Initialisation
	combatfacade.TransitionToState(combat, states.EventInitialize)
	combatfacade.TransitionToState(combat, states.EventInitializationComplete)
	t.Logf("État: %s", combatfacade.GetCurrentStateString(combat))

	// Simuler 3 tours
	for turn := 1; turn <= 3; turn++ {
		t.Logf("\n--- Tour %d ---", turn)

		// Tick ATB jusqu'à ce qu'une unité soit prête
		for i := 0; i < 200; i++ {
			combatfacade.TickATB(combat, 5)

			nextUnit := combatfacade.GetNextReadyUnit(combat)
			if nextUnit != nil {
				t.Logf("Unité prête: %s", nextUnit.ID())

				// Exécuter une action (Wait pour simplicité)
				result, err := combatfacade.ExecutePlayerAction(combat, nextUnit.ID(),
					combatfacade.CommandTypeWait, nil)

				if err != nil {
					t.Logf("Erreur lors de l'action: %v", err)
				} else if result != nil && result.Success {
					t.Logf("✅ Action réussie pour %s", nextUnit.ID())
				}

				break
			}
		}

		t.Logf("État après tour: %s", combatfacade.GetCurrentStateString(combat))
	}

	// Assert - Vérifier que le combat fonctionne
	t.Log("\n=== Fin du test d'intégration ===")
	t.Logf("État final: %s", combatfacade.GetCurrentStateString(combat))
	t.Logf("✅ Tous les patterns (State, Command, Observer, Validation) fonctionnent ensemble")
}
